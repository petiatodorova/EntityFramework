# ADO.NET is a standard .NET class library for accessing databases, processing data and XML
Supports connected, disconnected and ORM data access models


Connected data access model (SqlClient)
## Benefits:
Concurrency control is easier to maintain
Better chance to work with the most recent version of the data
## Drawbacks:
Needs a constant reliable network
Problems when scalability is an issue


## Data Providers are collections of classes that provide access to various databases
For different RDBMS systems different Data Providers are available
Several common objects are defined
--> Connection – to connect to the database
--> Command – to run an SQL command
--> DataReader – to retrieve data

## ORM data access model (Entity Framework Core)
Maps database tables to classes and objects
Objects can be automatically persisted in the database
Can operate in both connected and disconnected modes

## Entity Framework Core is a generic ORM framework
--> Create entity data model mapping the database
--> Open an object context
--> Retrieve data with LINQ / modify the tables in the object context
--> Persist the object context changes into the DB
--> Connection is automatically managed

## Database connection string
--> Defines the parameters needed to establishthe connection to the database
Settings for SQL Server connections:
--> Data Source / Server – server name / IP address + database instance name
--> Database / Initial Catalog – database name
--> User ID / Password – credentials
--> Integrated Security – false if credentials are provided

## Ways to prevent the SQL injection:
Preferred approach:
--> Use parameterized queries
--> Separate the SQL command from its arguments

ADO.NET provides an interface between our apps and the database engine
Different engines can be used with other data providers
SQL commands must be parametrized to prevent malicious behavior

----------------------------------------------------------------------------------------
# ORM Fundamentals

Object-Relational Mapping (ORM) allows manipulating databases using common classes and objects

ORM frameworks typically provide the following functionality:
Automatically generate SQL to perform data operations

--> Create object model from database schema (DB First model)
--> Create database schema from object model (Code First model)
--> Query data by object-oriented API

## Object-relational mapping (ORM) advantages:
--> Developer productivity: writing less code
--> Abstract from differences between object and relational world
--> Manageability of the CRUD operations for complex relationships
--> Easier maintainability
## Disadvantages:
--> Reduced performance (due to overhead or autogenerated SQL)
--> Reduces flexibility (some operations are hard to implement)



## The DbContext class
--> Holds the database connection and the DB Sets
--> Provides LINQ-based data access
--> Provides change tracking, and an API for CRUD operations

## DB Sets
--> Hold entities (objects with their attributes and relations)
--> Each database table is typically mapped to a single C# class

## Entity Classes
--> Entity classes are regular C# classes
--> Used for storing the data from the DB in-memory

## DbSet<T> Class
--> Generic collection with additional features
--> Each DbSet<T> corresponds to a single database table
--> Inherits from ICollection<T>
--> foreach-able
--> Supports LINQ operations
--> Usually several DbSets are part of a DbContext
--> Each DbSet tracks its own entities through a change tracker
    => Has every other feature of an ICollection<T>
    => Adding/Updating elements
    => Removing an entity/a range of entities
    => Checking for element existence
    => Accessing the count of elements
    
## DbContext Class
--> Holds several DbSet<T>
--> Responsible for populating the DbSets
--> Users create a DbContext, which inherits from DbContext. Using one DbSet per database table
    
## ChangeTracker<T> Class
--> Container for tracking changes
--> Holds 3 collections:
    => All entities
    => Added entities
    => Removed entities
--> Also can track modified entities Through cloning entities at initialization
--> Creating New Entities 
    => To create a new database row use the method Add(…) of the corresponding DbSet:
--> DbContext allows modifying entity properties and persisting them in the database
    => Just load an entity, modify it and call SaveChanges()

## ORM frameworks map database schema to objects in a programming language
## LINQ can be used to query the DB through the DB context

----------------------------------------------------------------------------------------
# Introduction to Entity Framework Core

Install-Package Microsoft.EntityFrameworkCore
Install-Package Microsoft.EntityFrameworkCore.SqlServer

## Scaffolding DbContext from DB with Scaffold-DbContext command in Package Manager Console:
Scaffold-DbContext 
  -Connection "Server=.;Database=…;Integrated Security=True" 
  -Provider Microsoft.EntityFrameworkCore.SqlServer 
  -OutputDir Data
Install-Package Microsoft.EntityFrameworkCore.Tools
Install-Package Microsoft.EntityFrameworkCore.SqlServer.Design

----------------------------------------------------------------------------------------
# Object composition denotes a "has-a" relationship
Fluent API (Model Builder) allows full control over DB mappings

--> Custom mappings are placed inside the OnModelCreating method of the DB context class

modelBuilder
	.Entity<Student>().HasKey("StudentKey");
    
modelBuilder.Entity<Person>()
  .Property(p => p.FirstName)
  .IsRequired()
  .HasMaxLength(50)
    
modelBuilder.Entity<Post>()
  .Property(p => p.LastUpdated)
  .ValueGeneratedOnAddOrUpdate()

modelBuilder.Entity<Post>()
  .Property(p => p.LastUpdated)
  .ValueGeneratedOnAddOrUpdate()


## Mappings can be placed in entity-specific classes
public class StudentConfiguration
  : IEntityTypeConfiguration<Student>
{
  public void Configure(EntityTypeBuilder<Student> builder)
  {
     builder.HasKey(c => c.StudentKey);
  }
}

## Annotations
public class Student
{
  [Key]
  public int Id { get; set; }
  public string Name { get; set; }
  public int AddressId { get; set; }
  [ForeignKey("Address")]
  public Address Address { get; set; }
}

 [ForeignKey(nameof(Student))]
  public Student Student { get; set; }
  
  modelBuilder.Entity<Address>()
  .HasOne(a => a.Student)
  .WithOne(s => s.Address)
  .HasForeignKey(a => a.StudentId);

## Department has many employees

public class Department
{
  public int Id { get; set; }
  public string Name { get; set; }
  
  public ICollection<Employee> Employees { get; set; }
}
    
## Employees have one department

public class Employee
{
  public int Id { get; set; }
  public string FirstName { get; set; }
  public string LastName { get; set; }

  public int DepartmentId { get; set; }
  public Department Department { get; set; }
}

## HasMany -> WithOne
modelBuilder.Entity<Post>()
  .HasMany(p => p.Comments)
  .WithOne(c => c.Post)
  .HasForeignKey(c => c.PostId);
    
## Many-to-Many
Requires a join entity (separate class) in EF Core

public class Course
{
  public string Name { get; set; }
  public ICollection<StudentCourse> StudentsCourses { get; set; }
}
    
public class Student
{
  public string FirstName { get; set; }
  public string LastName { get; set; }
  public ICollection<StudentCourse> StudentsCourses { get; set; }
}    

public class StudentCourse
{
  public int StudentId { get; set; }
  public Student Student { get; set; }

  public int CourseId { get; set; }
  public Course Course { get; set; }
}

## 
modelBuilder.Entity<StudentCourse>()
  .HasKey(sc => new { sc.StudentId, sc.CourseId });

builder.Entity<StudentCourse>()
  .HasOne(sc => sc.Student)
  .WithMany(s => s.StudentCourses)
  .HasForeignKey(sc => sc.StudentId);

builder.Entity<StudentCourse>()
  .HasOne(sc => sc.Course)
  .WithMany(s => s.StudentCourses)
  .HasForeignKey(sc => sc.CourseId);

## Inverse Properties

When two entities are related by more than one key
Entity Framework needs help from Inverse Properties

public class Person
{
  public int Id { get; set; }
  public string Name { get; set; }
  
  public Town PlaceOfBirth { get; set; }
  public Town CurrentResidence { get; set; }
}

public class Town
{
  public int Id { get; set; }
  public string Name { get; set; }
  [InverseProperty("PlaceOfBirth")]
  public ICollection<Person> Natives { get; set; }
  [InverseProperty("CurrentResidence")]
  public ICollection<Person> Residents { get; set; }
}

------------------------------------------------------------------

## Good Reasons to Use Select
Limit network traffic by reducing the queried columns

var employeesWithTown = context
  .Employees
  .Select(employee => new
  {
    EmployeeName = employee.FirstName,
    TownName = employee.Address.Town.Name
  });

--> SQL Server Profiler
SELECT [employee].[FirstName] AS [EmployeeName], [employee.Address.Town].[Name] AS [TownName]
     FROM [Employees] AS [employee]
LEFT JOIN [Addresses] AS [employee.Address] ON [employee].[AddressID] = [employee.Address].[AddressID]
LEFT JOIN [Towns] AS [employee.Address.Town] ON [employee.Address].[TownID] =       		 	  [employee.Address.Town].[TownID]

## Good Reasons not to Use Select
--> Data that is selected is not of the initial entity type
--> Data cannot be modified (updated, deleted). Entity is of a different type
--> Not associated with the context anymore

## Joining Tables in EF: Using Join()
var employees = 
  softUniEntities.Employees.Join(
    softUniEntities.Departments,
    (e => e.DepartmentID),
    (d => d.DepartmentID), 
    (e, d) => new {
      Employee = e.FirstName, 
      JobTitle = e.JobTitle, 
      Department = d.Name
    }
  );

## Grouping
var groupedCustomers = softUniEntities.Employees
  .GroupBy(employee => employee.JobTitle);

## Select(), GroupBy() can work with custom classes Result Models
public class UserResultModel
{
  public string FullName { get; set; }
  public string Age { get; set; }
}

var currentUser = context.Users
  .Where(u => u.Id == 8)
  .Select(u => new UserResultModel
  {
    FullName = u.FirstName + " " + u.LastName,
    Age = u.Age
  })
  .SingleOrDefault();

--> The new type can be used in a method signature:

public UserResultModel GetUserInfo(int Id) { … }

## Attributes
using System.ComponentModel.DataAnnotations;

--> For a full set of configuration options you need the Fluent API
[Key]
public int StudentKey { get; set; }

--> Composite key is only defined using Fluent API for now:
builder.Entity<EmployeesProjects>()
	.HasKey(k => new { k.EmployeeId, k.ProjectId });

[ForeignKey("Order")]
  public int OrderRefId { get; set; }
  public Order Order { get; set; }

--> Table – manually specify the name of the table in the DB

[Table("StudentMaster", Schema = "Admin")]
public class Student
{
  …
}

--> Column
public class Student
{
  …
  [Column("StudentName", Order = 2, TypeName="varchar(50)")]
  public string Name { get; set; }     
}

--> Required – mark a nullable property as NOT NULL in the DB
Will throw an exception if not set to a value
Non-nullable types (e.g. int) will not throw an exception (will be set to language-specific default value)
--> MinLength – specifies min length of a string (client validation)
--> MaxLength / StringLength – specifies max length of a string (both client and DB validation)
--> Range – set lower and/or upper limits of numeric property (client validation)

builder.Entity<Car>()
        .HasIndex(u => u.RegistrationNumber)
        .IsUnique();

## Validation Method
using System.ComponentModel.DataAnnotations;

private bool IsValid(object obj)
{
	var validationContext = new ValidationContext(obj);
	var validationResults = new List<ValidationResult>();

	return Validator.TryValidateObject(obj, validationContext, 					validationResults, true);
}

## Shadow properties are not defined in your .NET entity class
They are useful when there is data in the database that should not be exposed on the mapped entity types.

builder.Entity<Project>() 	
    .Property<DateTime>("LastUpdated");

--> Change shadow property value
context.Entry(Project).Property("LastUpdated")
	.CurrentValue = DateTime.Now;
    
The Fluent API gives us full control over Entity Framework object mappings
Information overhead can be limited by selecting only the needed properties
ResultModels can be used to move aggregated data between methods
Attributes can be used to express special table relationships and to customize entity behaviour


## Attaching and Detaching Objects
In Entity Framework, objects can be:
--> Attached to the object context (tracked object). Attached objects are tracked and managed by the DbContext.
--> Detached from an object context (untracked object). Detached objects are not referenced by the DbContext.

--> SaveChanges() persists all changes in DB

## Bulk Operations
Z.EntityFramework.Plus gives you the ability to perform bulk update/delete of entities
--> Bulk Delete
context.Employees
  .Where(u => u.FirstName == "Pesho")
  .Delete();

Update all Employees with name “Nasko” to “Plamen”
context.Employees
  .Where(t => t.Name == "Nasko")
  .Update(u => new Employee() {Name = "Plamen"});

--> Update all Employees’ age to 99 who have the name “Plamen”
IQueryable<Employee> employees = context.Employees
  .Where(employee => employee.Name == "Plamen");

employees.Update(employee => new Employee() { Age = 99 });

## Types of Loading
--> Explicit loading loads all records when they’re needed
--> Eager loading loads all related records of an entity at once
--> Lazy Loading delays loading of data until it is used
EF Core enables lazy-loading for any navigation property that can be overridden 
Offers better performance in certain cases
Less RAM usage
Smaller result sets returned

## Cascade Delete Scenarios 
Required FK with cascade delete set to true, deletes everything related to the deleted property
Required FK with cascade delete set to false, throws exception (it cannot leave the navigational property with no value) 
Optional FK with cascade delete set to true, deletes everything related to the deleted property.
Optional FK with cascade delete set to false, sets the value of the FK to NULL
--> DeleteBehavior.Cascade
Deletes related entities (default for required FK)
--> DeleteBehavior.Restrict
Throws exception on delete
--> DeleteBehavior.ClientSetNull
Default behavior for optional FK (does not affect database)
--> DeleteBehavior.SetNull
Sets the property to null (affects database)


## A DTO is an object that carries data between processes
Used to aggregate only the needed information in a single call
Doesn't contain any logic – only stores values
public class ProductDTO
{
  public string Name { get; set; }
  public int StockQty { get; set; }
}

## DTO Usage Scenarios
--> Remove circular references 
--> Hide particular properties that clients are not supposed to view
--> Omit some properties in order to reduce payload size
--> Flatten object graphs that contain nested objects to make them more convenient for clients
--> Decouple your service layer from your database layer

## Manual Mapping
Get product name and stock quantity in a new DTO object

var product = context.Products.FirstOrDefault();
var productDto = new ProductDTO
{
  Name = product.Name,
  StockQty = product.ProductStocks
    .Sum(ps => ps.Quantity)
};

## Automapper - Library to eliminate manual mapping code
--> Initialization and Configuration

Mapper.Initialize(cfg => cfg.CreateMap<Product, ProductDTO>());

--> Properties will be mapped by name

var product = context.Products.FirstOrDefault();
ProductDTO dto = Mapper.Map<ProductDTO>(product);

--> 
Mapper.Initialize(cfg => 
{
  cfg.CreateMap<Product, ProductDTO>();
  cfg.CreateMap<Order, OrderDTO>();
  cfg.CreateMap<Client, ClientDTO>();
  cfg.CreateMap<SupportTicket, TicketDTO>();
});

To reduce round-trip latency and payload size, data is transformed into a DTO
AutoMapper is a library that automates this process and reduces boilerplate code
Complex objects can be flattened to fractions of their sizes

## using System.Runtime.Serialization.Json;
--> Serialize with DataContractJsonSerializer an object:

static string SerializeJson<T>(T obj)
{
  var serializer = new DataContractJsonSerializer(obj.GetType());
  using (var stream = new MemoryStream())
  {
    serializer.WriteObject(stream, obj);
    var result = Encoding.UTF8.GetString(stream.ToArray());
    return result;
  }
}



--> Deserialize with DataContractJsonSerializer a JSON string:

static T DeserializeJson<T>(string jsonString)
{
  var serializer = new DataContractJsonSerializer(typeof(T));
  var jsonStringBytes = Encoding.UTF8.GetBytes(jsonString);
  using (var stream = new MemoryStream(jsonStringBytes))
  {
    var result = (T)serializer.ReadObject(stream);
    return result;
  }
}

## JSON.NET exposes a static service JsonConvert

--> To Serialize an object:
var jsonProduct = JsonConvert.SerializeObject(product);

--> To Deserialize an object:
var objProduct = 
  JsonConvert.DeserializeObject<Product>(jsonProduct);

## Configuring JSON.NET
By default, the result is a single line of text.
To indent the output string use Formatting.Indented.

JsonConvert.SerializeObject(products, Formatting.Indented);

--> Deserializing to anonymous types:

var json = @"{ 'firstName': 'Vladimir',
               'lastName': 'Georgiev',
               'jobTitle': 'Technical Trainer' }";
               
var template = new 
{
    FirstName = string.Empty,
    LastName = string.Empty,
    Occupation = string.Empty
};

var person = JsonConvert.DeserializeAnonymousType(json, template);

--> JSON.NET Parsing of Objects
public class User
{
  [JsonProperty("user")]
  public string Username { get; set; }
  [JsonIgnore]
  public string Password { get; set; }
}

DefaultContractResolver contractResolver = new DefaultContractResolver()
{
    NamingStrategy = new SnakeCaseNamingStrategy()
};

var serialized = JsonConvert.SerializeObject(person, new JsonSerializerSettings()
{
    ContractResolver = contractResolver,
    Formatting = Formatting.Indented
});

--> LINQ-to-JSON works with JObjects
JObject obj = JObject.Parse(jsonProduct);
var people = JObject.Parse(File.ReadAllText(@"c:\people.json"))
foreach (JToken person in people)
{
  Console.WriteLine(person["FirstName"]); // Ivan
  Console.WriteLine(person["LastName"]); // Petrov
}

var json = JObject.Parse(@"{'products': [
  {'name': 'Fruits', 'products': ['apple', 'banana']},
  {'name': 'Vegetables', 'products': ['cucumber']}]}");

var products = json["products"].Select(t =>
  string.Format("{0} ({1})",
    t["name"],
    string.Join(", ", c["products"])
))

SON is cross platform data format
DataContractJsonSerializer is the default JSON Parser in C#
JSON.NET is a fast framework for working with JSON data


## XML Syntax

Header – defines a version and character encoding
<?xml version="1.0" encoding="UTF-8"?>
--> Elements – define the structure
--> Attributes – element metadata
--> Values – actual data, that can also be nested elements

--> XDocument – represents a LINQ-enabled XML document (containing prolog, root element, …)
--> XElement – main component holding information

## Reading XML
string str = @"<?xml version=""1.0""?>
<!-- comment at the root level -->
<Root>
    <Child>Content</Child>
</Root>";

XDocument doc = XDocument.Parse(str);

--> Loading XML directly from file:
XDocument xmlDoc = XDocument.Load("../../books.xml");

--> Working with XDocument

var cars = xmlDoc.Root.Elements();
foreach (var car in cars)
{
  string make = car.Element("make").Value;
  string model = car.Element("model").Value;
  Console.WriteLine($"{make} {model}");
}

--> set element - If it doesn't exist, it will be added, 
    If it is set to null, it will be removed

customer.SetElementValue("birth-date", "1990-10-04T00:00:00");

--> remove element
var youngDriver = customer.Element("is-young-driver");
youngDriver.Remove();

-----------------------------------------------
# Design Patterns
--> General and reusable solutions to common problems in software design
--> A template for solving given problems
--> Add additional layers of abstraction in order to reach flexibility

## Creational patterns - Singleton, Prototype
Deal with initialization and configuration of classes and objects

## Structural patterns - Façade Pattern, Composite Pattern - Used when
You have different objects that youwant to treat the same way
You want to present hierarchyof objects

Describe ways to assemble objects to implement new functionality
Composition of classes and objects

## Behavioral patterns - Command Pattern, Template Pattern


